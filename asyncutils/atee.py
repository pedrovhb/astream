from __future__ import annotations

import asyncio
from asyncio import Future
from typing import TypeAlias, AsyncIterator, AsyncIterable, TypeVar

T = TypeVar("T")

ItemAndNextFuture: TypeAlias = Future[tuple[T, "ItemAndNextFuture[T]"]]


async def _cloned_aiter(future: ItemAndNextFuture[T]) -> AsyncIterator[T]:
    """Helper function for `clone_async_iterator`."""
    while True:
        try:
            item, future = await future
            yield item
        except asyncio.CancelledError:
            return


def tee_async_iterable(source: AsyncIterable[T], n_clones: int) -> tuple[AsyncIterator[T], ...]:
    """Create n clones of an async iterable, each receiving every item generated by the source.

    Note that this is not a true copy, as the source iterable is not duplicated. Instead, each
    copy is a separate iterator that receives the same items from the source iterable. The elements
    are not copied, so if a list is yielded from the source iterable, each copy will receive the
    same list object.

    The original iterable should not be iterated over after the copies are created, as this will
    cause the copies to miss items.

    Objects yielded from the source iterable will also stay in memory until all copies have
    finished iterating over them. This can cause memory issues in a long-running program if the
    copied async iterators are not consumed at the same rate as the source iterable.
      Todo - Perhaps use weak references to allow the source iterable to be garbage collected

    Args:
        source: The source iterable to copy.
        n_clones: The number of copies to create.

    Returns:
        A tuple of async iterators, each receiving the same items from the source iterable.
    """
    futures = [ItemAndNextFuture[T]() for _ in range(n_clones)]

    async def _copier() -> None:
        futs = futures

        async for item in source:

            new_futs: list[ItemAndNextFuture[T]] = []
            for fut in futs:
                next_fut = ItemAndNextFuture[T]()
                new_futs.append(next_fut)
                fut.set_result((item, next_fut))
            futs = new_futs

        for fut in futs:
            fut.cancel(StopAsyncIteration)

    asyncio.create_task(_copier())
    copied = tuple(_cloned_aiter(fut) for fut in futures)
    return copied


atee = tee_async_iterable
